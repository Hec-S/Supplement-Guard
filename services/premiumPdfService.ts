import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { ClaimData, InvoiceLineItem } from '../types';

// Extended interface for premium PDF generation
interface PremiumClaimData extends ClaimData {
  claimId?: string;
  riskLevel?: string;
  contributingFactors?: string[];
  aiAnalysis?: {
    summary: string;
    keyChanges?: string[];
  };
}

// Professional color palette
const COLORS = {
  // Primary colors
  primary: '#1a365d',      // Deep blue
  secondary: '#2d3748',    // Dark gray
  accent: '#3182ce',       // Medium blue
  
  // Status colors
  newItem: '#FF0000',      // Vibrant red for new items
  changedItem: '#FF8C00',  // Distinctive orange for changed items
  sameItem: '#2d3748',     // Dark gray for unchanged items
  
  // Background colors
  headerBg: '#f7fafc',     // Light gray
  alternateRow: '#f8f9fa', // Very light gray
  
  // Text colors
  textPrimary: '#1a202c',  // Almost black
  textSecondary: '#4a5568', // Medium gray
  textMuted: '#718096',    // Light gray
  
  // Accent colors
  success: '#38a169',      // Green
  warning: '#d69e2e',      // Yellow
  danger: '#e53e3e',       // Red
  info: '#3182ce'          // Blue
};

// Typography configuration
const TYPOGRAPHY = {
  fonts: {
    primary: 'helvetica',
    secondary: 'times',
    monospace: 'courier'
  },
  sizes: {
    title: 24,
    heading: 18,
    subheading: 14,
    body: 11,
    caption: 9,
    small: 8
  },
  weights: {
    normal: 'normal',
    bold: 'bold'
  }
};

// Layout configuration
const LAYOUT = {
  margins: {
    top: 35,
    bottom: 35,
    left: 30,
    right: 30
  },
  spacing: {
    section: 15,
    paragraph: 8,
    line: 5,
    table: 10
  },
  pageSize: {
    width: 210, // A4 width in mm
    height: 297 // A4 height in mm
  }
};

export class PremiumPdfGenerator {
  private doc: jsPDF;
  private currentY: number;
  private pageWidth: number;
  private pageHeight: number;
  private contentWidth: number;
  private pageNumber: number;

  constructor() {
    this.doc = new jsPDF('portrait', 'mm', 'a4');
    this.pageWidth = LAYOUT.pageSize.width;
    this.pageHeight = LAYOUT.pageSize.height;
    this.contentWidth = this.pageWidth - LAYOUT.margins.left - LAYOUT.margins.right;
    this.currentY = LAYOUT.margins.top;
    this.pageNumber = 1;
    
    // Set default font
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.normal);
  }

  private addNewPage(): void {
    this.doc.addPage();
    this.pageNumber++;
    this.currentY = LAYOUT.margins.top;
    this.addPageHeader();
    this.addPageFooter();
  }

  private checkPageSpace(requiredHeight: number): void {
    const availableSpace = this.pageHeight - LAYOUT.margins.bottom - this.currentY;
    if (requiredHeight > availableSpace) {
      this.addNewPage();
    }
  }

  private addPageHeader(): void {
    const headerHeight = 25;
    
    // Header background
    this.doc.setFillColor(...this.hexToRgb(COLORS.headerBg));
    this.doc.rect(0, 0, this.pageWidth, headerHeight, 'F');
    
    // Header border
    this.doc.setDrawColor(...this.hexToRgb(COLORS.primary));
    this.doc.setLineWidth(0.5);
    this.doc.line(0, headerHeight, this.pageWidth, headerHeight);
    
    // Company logo area (placeholder)
    this.doc.setFillColor(...this.hexToRgb(COLORS.primary));
    this.doc.rect(LAYOUT.margins.left, 8, 40, 10, 'F');
    
    // Company name
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
    this.doc.setFontSize(TYPOGRAPHY.sizes.heading);
    this.doc.setTextColor(...this.hexToRgb(COLORS.primary));
    this.doc.text('SupplementGuard', LAYOUT.margins.left + 45, 15);
    
    // Page number
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.normal);
    this.doc.setFontSize(TYPOGRAPHY.sizes.caption);
    this.doc.setTextColor(...this.hexToRgb(COLORS.textSecondary));
    this.doc.text(`Page ${this.pageNumber}`, this.pageWidth - LAYOUT.margins.right - 20, 15);
  }

  private addPageFooter(): void {
    const footerY = this.pageHeight - 15;
    
    // Footer line
    this.doc.setDrawColor(...this.hexToRgb(COLORS.textMuted));
    this.doc.setLineWidth(0.3);
    this.doc.line(LAYOUT.margins.left, footerY - 5, this.pageWidth - LAYOUT.margins.right, footerY - 5);
    
    // Footer text
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.normal);
    this.doc.setFontSize(TYPOGRAPHY.sizes.small);
    this.doc.setTextColor(...this.hexToRgb(COLORS.textMuted));
    
    const currentDate = new Date().toLocaleDateString();
    this.doc.text(`Generated by SupplementGuard on ${currentDate}`, LAYOUT.margins.left, footerY);
    this.doc.text('Confidential Document', this.pageWidth - LAYOUT.margins.right - 40, footerY);
  }

  private hexToRgb(hex: string): [number, number, number] {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16)
    ] : [0, 0, 0];
  }

  private addStyledText(text: string, options: {
    fontSize?: number;
    fontWeight?: string;
    color?: string;
    align?: 'left' | 'center' | 'right';
    maxWidth?: number;
    lineHeight?: number;
  } = {}): void {
    const {
      fontSize = TYPOGRAPHY.sizes.body,
      fontWeight = TYPOGRAPHY.weights.normal,
      color = COLORS.textPrimary,
      align = 'left',
      maxWidth = this.contentWidth,
      lineHeight = fontSize * 1.4
    } = options;

    this.doc.setFont(TYPOGRAPHY.fonts.primary, fontWeight);
    this.doc.setFontSize(fontSize);
    this.doc.setTextColor(...this.hexToRgb(color));

    const lines = this.doc.splitTextToSize(text, maxWidth);
    const textHeight = lines.length * (lineHeight / 3.78); // Convert to mm

    this.checkPageSpace(textHeight + LAYOUT.spacing.line);

    let x = LAYOUT.margins.left;
    if (align === 'center') {
      x = this.pageWidth / 2;
    } else if (align === 'right') {
      x = this.pageWidth - LAYOUT.margins.right;
    }

    this.doc.text(lines, x, this.currentY, { align });
    this.currentY += textHeight + LAYOUT.spacing.line;
  }

  private addSection(title: string, content?: () => void): void {
    this.checkPageSpace(30);

    // Section divider
    this.doc.setDrawColor(...this.hexToRgb(COLORS.accent));
    this.doc.setLineWidth(0.8);
    this.doc.line(LAYOUT.margins.left, this.currentY, this.pageWidth - LAYOUT.margins.right, this.currentY);
    this.currentY += 3;

    // Section title
    this.addStyledText(title, {
      fontSize: TYPOGRAPHY.sizes.heading,
      fontWeight: TYPOGRAPHY.weights.bold,
      color: COLORS.primary
    });

    this.currentY += LAYOUT.spacing.paragraph;

    if (content) {
      content();
    }

    this.currentY += LAYOUT.spacing.section;
  }

  private addFraudScoreCard(fraudScore: number, riskLevel: string): void {
    const cardHeight = 40;
    this.checkPageSpace(cardHeight);

    const cardY = this.currentY;
    const cardWidth = this.contentWidth;

    // Determine colors based on risk level
    let bgColor = COLORS.success;
    let textColor = '#ffffff';
    
    if (riskLevel.toLowerCase().includes('high')) {
      bgColor = COLORS.danger;
    } else if (riskLevel.toLowerCase().includes('medium')) {
      bgColor = COLORS.warning;
    }

    // Card background with gradient effect
    this.doc.setFillColor(...this.hexToRgb(bgColor));
    this.doc.roundedRect(LAYOUT.margins.left, cardY, cardWidth, cardHeight, 3, 3, 'F');

    // Card border
    this.doc.setDrawColor(...this.hexToRgb(COLORS.primary));
    this.doc.setLineWidth(0.5);
    this.doc.roundedRect(LAYOUT.margins.left, cardY, cardWidth, cardHeight, 3, 3, 'S');

    // Score circle
    const circleX = LAYOUT.margins.left + 25;
    const circleY = cardY + 20;
    const circleRadius = 15;

    this.doc.setFillColor(255, 255, 255);
    this.doc.circle(circleX, circleY, circleRadius, 'F');
    this.doc.setDrawColor(...this.hexToRgb(bgColor));
    this.doc.setLineWidth(2);
    this.doc.circle(circleX, circleY, circleRadius, 'S');

    // Score text
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
    this.doc.setFontSize(TYPOGRAPHY.sizes.heading);
    this.doc.setTextColor(...this.hexToRgb(bgColor));
    this.doc.text(fraudScore.toString(), circleX, circleY + 2, { align: 'center' });

    // Risk level text
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
    this.doc.setFontSize(TYPOGRAPHY.sizes.subheading);
    this.doc.setTextColor(255, 255, 255);
    this.doc.text('Fraud Risk Assessment', LAYOUT.margins.left + 55, cardY + 15);
    
    this.doc.setFontSize(TYPOGRAPHY.sizes.body);
    this.doc.text(`Risk Level: ${riskLevel}`, LAYOUT.margins.left + 55, cardY + 25);
    this.doc.text(`Score: ${fraudScore}/100`, LAYOUT.margins.left + 55, cardY + 32);

    this.currentY += cardHeight + LAYOUT.spacing.section;
  }

  private addEnhancedTable(title: string, data: any[], columns: any[]): void {
    this.checkPageSpace(50);

    // Table title
    this.addStyledText(title, {
      fontSize: TYPOGRAPHY.sizes.subheading,
      fontWeight: TYPOGRAPHY.weights.bold,
      color: COLORS.primary
    });

    const tableData = data.map(item => {
      return columns.map(col => {
        let value = item[col.dataKey] || '';
        if (typeof value === 'number') {
          value = col.dataKey.toLowerCase().includes('price') || col.dataKey.toLowerCase().includes('total') 
            ? `$${value.toFixed(2)}` 
            : value.toString();
        }
        return value.toString();
      });
    });

    // Calculate optimal column widths
    const totalWidth = this.contentWidth - 10;
    const columnWidths = columns.map(col => col.width || totalWidth / columns.length);

    (this.doc as any).autoTable({
      head: [columns.map(col => col.header)],
      body: tableData,
      startY: this.currentY,
      margin: { left: LAYOUT.margins.left, right: LAYOUT.margins.right },
      columnStyles: columns.reduce((acc, col, index) => {
        acc[index] = {
          cellWidth: columnWidths[index],
          fontSize: TYPOGRAPHY.sizes.body,
          textColor: this.hexToRgb(COLORS.textPrimary),
          fontStyle: TYPOGRAPHY.weights.normal
        };
        return acc;
      }, {} as any),
      headStyles: {
        fillColor: this.hexToRgb(COLORS.primary),
        textColor: [255, 255, 255],
        fontSize: TYPOGRAPHY.sizes.body,
        fontStyle: TYPOGRAPHY.weights.bold,
        halign: 'center'
      },
      bodyStyles: {
        fontSize: TYPOGRAPHY.sizes.body,
        textColor: this.hexToRgb(COLORS.textPrimary)
      },
      alternateRowStyles: {
        fillColor: this.hexToRgb(COLORS.alternateRow)
      },
      styles: {
        cellPadding: 4,
        lineColor: this.hexToRgb(COLORS.textMuted),
        lineWidth: 0.3
      },
      didParseCell: (data: any) => {
        // Apply color coding for supplement invoice items
        if (title.toLowerCase().includes('supplement') && data.section === 'body') {
          const rowIndex = data.row.index;
          const originalItem = data[rowIndex];
          
          // Check if item is new or changed based on properties
          let isNew = false;
          let isChanged = false;
          
          if (originalItem && typeof originalItem === 'object') {
            isNew = originalItem.isNew === true;
            isChanged = originalItem.isChanged === true;
          }
          
          // Also check status column if it exists
          const statusColumnIndex = columns.findIndex(col => col.dataKey === 'status');
          if (statusColumnIndex >= 0 && data.row.raw && data.row.raw[statusColumnIndex]) {
            const status = data.row.raw[statusColumnIndex].toString().toUpperCase();
            isNew = isNew || status === 'NEW';
            isChanged = isChanged || status === 'CHANGED';
          }
          
          if (isNew) {
            data.cell.styles.textColor = this.hexToRgb(COLORS.newItem);
            data.cell.styles.fontStyle = TYPOGRAPHY.weights.bold;
            data.cell.styles.fillColor = [255, 240, 240]; // Light red background
          } else if (isChanged) {
            data.cell.styles.textColor = this.hexToRgb(COLORS.changedItem);
            data.cell.styles.fontStyle = TYPOGRAPHY.weights.bold;
            data.cell.styles.fillColor = [255, 248, 220]; // Light orange background
          }
        }
      }
    });

    this.currentY = (this.doc as any).lastAutoTable.finalY + LAYOUT.spacing.table;
  }

  private addKeyChangesSection(keyChanges: string[]): void {
    this.addSection('Key Changes Analysis', () => {
      keyChanges.forEach((change, index) => {
        // Add bullet point with custom styling
        this.doc.setFillColor(...this.hexToRgb(COLORS.accent));
        this.doc.circle(LAYOUT.margins.left + 3, this.currentY - 2, 1.5, 'F');
        
        this.addStyledText(change, {
          fontSize: TYPOGRAPHY.sizes.body,
          color: COLORS.textPrimary,
          maxWidth: this.contentWidth - 10
        });
        
        this.currentY += LAYOUT.spacing.line;
      });
    });
  }

  public generateClaimReport(claimData: PremiumClaimData): void {
    // Initialize first page
    this.addPageHeader();
    this.addPageFooter();

    // Document title
    this.addStyledText('SupplementGuard Claim Report', {
      fontSize: TYPOGRAPHY.sizes.title,
      fontWeight: TYPOGRAPHY.weights.bold,
      color: COLORS.primary,
      align: 'center'
    });

    // Claim information header
    this.currentY += LAYOUT.spacing.section;
    const claimInfo = [
      `Claim ID: ${claimData.claimId || claimData.id}`,
      `Generated: ${new Date().toLocaleDateString()}`,
      `Analysis Date: ${new Date().toLocaleDateString()}`
    ];

    claimInfo.forEach(info => {
      this.addStyledText(info, {
        fontSize: TYPOGRAPHY.sizes.body,
        color: COLORS.textSecondary,
        align: 'center'
      });
    });

    this.currentY += LAYOUT.spacing.section;

    // Fraud Risk Assessment Card
    this.addFraudScoreCard(claimData.fraudScore, claimData.riskLevel || 'Medium Risk');

    // Contributing Factors Section
    if (claimData.contributingFactors && claimData.contributingFactors.length > 0) {
      this.addSection('Contributing Factors', () => {
        claimData.contributingFactors!.forEach((factor, index) => {
          this.addStyledText(`${index + 1}. ${factor}`, {
            fontSize: TYPOGRAPHY.sizes.body,
            color: COLORS.textPrimary
          });
          this.currentY += LAYOUT.spacing.line;
        });
      });
    } else {
      // Use fraud reasons as contributing factors
      this.addSection('Contributing Factors', () => {
        claimData.fraudReasons.forEach((reason, index) => {
          this.addStyledText(`${index + 1}. ${reason}`, {
            fontSize: TYPOGRAPHY.sizes.body,
            color: COLORS.textPrimary
          });
          this.currentY += LAYOUT.spacing.line;
        });
      });
    }

    // Analysis Summary
    this.addSection('Analysis Summary', () => {
      const summary = claimData.aiAnalysis?.summary || claimData.invoiceSummary || 'Analysis completed successfully.';
      this.addStyledText(summary, {
        fontSize: TYPOGRAPHY.sizes.body,
        color: COLORS.textPrimary
      });
    });

    // Key Changes
    if (claimData.aiAnalysis?.keyChanges && claimData.aiAnalysis.keyChanges.length > 0) {
      this.addKeyChangesSection(claimData.aiAnalysis.keyChanges);
    }

    // Original Invoice Table
    if (claimData.originalInvoice && claimData.originalInvoice.lineItems.length > 0) {
      this.addEnhancedTable('Original Invoice', claimData.originalInvoice.lineItems, [
        { header: 'Description', dataKey: 'description', width: 80 },
        { header: 'Qty', dataKey: 'quantity', width: 20 },
        { header: 'Price', dataKey: 'price', width: 30 },
        { header: 'Total', dataKey: 'total', width: 30 }
      ]);
    }

    // Supplement Invoice Table with Color Coding
    if (claimData.supplementInvoice && claimData.supplementInvoice.lineItems.length > 0) {
      // Sort supplement items by status: NEW first, then CHANGED, then SAME
      const sortedSupplementItems = [...claimData.supplementInvoice.lineItems].sort((a, b) => {
        // Define status priority: NEW = 1, CHANGED = 2, SAME = 3
        const getStatusPriority = (item: any) => {
          if (item.isNew) return 1;
          if (item.isChanged) return 2;
          return 3;
        };
        
        return getStatusPriority(a) - getStatusPriority(b);
      });
      
      // Add status property to each item for the table
      const itemsWithStatus = sortedSupplementItems.map(item => ({
        ...item,
        status: item.isNew ? 'NEW' : item.isChanged ? 'CHANGED' : 'SAME'
      }));
      
      this.addEnhancedTable('Supplement Invoice', itemsWithStatus, [
        { header: 'Description', dataKey: 'description', width: 70 },
        { header: 'Qty', dataKey: 'quantity', width: 15 },
        { header: 'Price', dataKey: 'price', width: 25 },
        { header: 'Total', dataKey: 'total', width: 25 },
        { header: 'Status', dataKey: 'status', width: 25 }
      ]);

      // Add color legend
      this.currentY += LAYOUT.spacing.paragraph;
      this.addStyledText('Color Legend:', {
        fontSize: TYPOGRAPHY.sizes.body,
        fontWeight: TYPOGRAPHY.weights.bold,
        color: COLORS.textPrimary
      });

      // New items legend
      this.doc.setFillColor(...this.hexToRgb(COLORS.newItem));
      this.doc.rect(LAYOUT.margins.left, this.currentY - 2, 4, 4, 'F');
      this.addStyledText('New Items', {
        fontSize: TYPOGRAPHY.sizes.caption,
        color: COLORS.newItem,
        maxWidth: this.contentWidth - 10
      });

      // Changed items legend
      this.doc.setFillColor(...this.hexToRgb(COLORS.changedItem));
      this.doc.rect(LAYOUT.margins.left, this.currentY - 2, 4, 4, 'F');
      this.addStyledText('Changed Items', {
        fontSize: TYPOGRAPHY.sizes.caption,
        color: COLORS.changedItem,
        maxWidth: this.contentWidth - 10
      });
    }

    // Needs Warranty Section
    this.currentY += LAYOUT.spacing.section;
    this.checkPageSpace(100);
    
    // Filter items from SUPPLEMENT INVOICE ONLY that need warranty (contain "Rpr" or "Repl" in description)
    const warrantyItems = (claimData.supplementInvoice?.lineItems || [])
      .filter(item => {
        const desc = item.description;
        // Check for "Rpr" or "Repl" (case-sensitive to match actual abbreviations)
        return desc.includes('Rpr') || desc.includes('Repl');
      });
    
    if (warrantyItems.length > 0) {
      // Section title with background
      this.doc.setFillColor(...this.hexToRgb('#FEF2F2')); // Light red background
      this.doc.rect(LAYOUT.margins.left - 5, this.currentY - 5, this.contentWidth + 10, 25, 'F');
      
      this.addStyledText('NEEDS WARRANTY', {
        fontSize: TYPOGRAPHY.sizes.heading,
        fontWeight: TYPOGRAPHY.weights.bold,
        color: '#991B1B' // Dark red
      });
      
      this.currentY += LAYOUT.spacing.paragraph;
      
      // Warranty notice
      this.addStyledText('The following supplement items require warranty coverage as they involve repairs or replacements:', {
        fontSize: TYPOGRAPHY.sizes.body,
        color: COLORS.textSecondary
      });
      
      this.currentY += LAYOUT.spacing.paragraph;
      
      // Prepare warranty data with work type classification and price comparison
      const warrantyData = warrantyItems.map(item => {
        // Find the corresponding original item to get price comparison
        const originalItem = claimData.originalInvoice?.lineItems.find(
          orig => orig.description.toLowerCase().trim() === item.description.toLowerCase().trim()
        );
        
        const originalTotal = originalItem ? originalItem.total : 0;
        const priceChange = item.total - originalTotal;
        
        // Determine the type of work based on description
        const desc = item.description;
        let workType = '';
        let workTypeColor = COLORS.textPrimary;
        
        if (desc.includes('Repl')) {
          workType = 'REPLACEMENT';
          workTypeColor = '#DC2677'; // Pink
        } else if (desc.includes('Rpr')) {
          workType = 'REPAIR';
          workTypeColor = '#EA580C'; // Orange
        } else {
          workType = 'SERVICE';
          workTypeColor = COLORS.textSecondary;
        }
        
        return {
          description: item.description,
          workType: workType,
          workTypeColor: workTypeColor,
          originalAmount: originalTotal,
          newAmount: item.total,
          priceChange: priceChange,
          warrantyStatus: 'NEEDS WARRANTY'
        };
      });
      
      // Create enhanced warranty table
      this.createWarrantyTable(warrantyData);
      
      this.currentY += LAYOUT.spacing.section;
    }

    // Disclaimer Section
    this.currentY += LAYOUT.spacing.section;
    this.checkPageSpace(100);
    
    // Disclaimer title
    this.addStyledText('IMPORTANT DISCLAIMER', {
      fontSize: TYPOGRAPHY.sizes.subheading,
      fontWeight: TYPOGRAPHY.weights.bold,
      color: '#8B0000' // Dark red
    });
    
    this.currentY += LAYOUT.spacing.paragraph;
    
    // Disclaimer content
    const disclaimerText = `ALL ESTIMATE AND SUPPLEMENT PAYMENTS WILL BE ISSUED TO THE VEHICLE OWNER.

The repair contract exists solely between the vehicle owner and the repair facility. The insurance company is not involved in this agreement and does not assume responsibility for repair quality, timelines, or costs. All repair-related disputes must be handled directly with the repair facility.

Please note: Any misrepresentation of repairs, labor, parts, or supplements—including unnecessary operations or inflated charges—may constitute insurance fraud and will result in further review or investigation.`;
    
    // Draw disclaimer box with border
    const disclaimerStartY = this.currentY - LAYOUT.spacing.paragraph;
    
    // Split disclaimer into paragraphs for better formatting
    const disclaimerParagraphs = disclaimerText.split('\n\n');
    disclaimerParagraphs.forEach((paragraph, index) => {
      if (index > 0) this.currentY += LAYOUT.spacing.line;
      
      this.addStyledText(paragraph, {
        fontSize: TYPOGRAPHY.sizes.body,
        color: COLORS.textPrimary
      });
    });
    
    // Draw border around disclaimer
    const disclaimerEndY = this.currentY + LAYOUT.spacing.line;
    const disclaimerHeight = disclaimerEndY - disclaimerStartY;
    this.doc.setDrawColor(...this.hexToRgb(COLORS.textMuted));
    this.doc.setLineWidth(0.5);
    this.doc.roundedRect(LAYOUT.margins.left - 5, disclaimerStartY, this.contentWidth + 10, disclaimerHeight, 2, 2, 'S');
  }

  private createWarrantyTable(data: any[]): void {
    const headers = ['Description', 'Type', 'Original', 'New', 'Change', 'Warranty Status'];
    const colWidths = [50, 25, 25, 25, 25, 30];
    
    // Table header
    this.doc.setFillColor(...this.hexToRgb(COLORS.primary));
    this.doc.rect(LAYOUT.margins.left, this.currentY, this.contentWidth, 10, 'F');
    
    this.doc.setTextColor(255, 255, 255);
    this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
    this.doc.setFontSize(TYPOGRAPHY.sizes.body);
    
    let currentX = LAYOUT.margins.left;
    headers.forEach((header, index) => {
      this.doc.text(header, currentX + 2, this.currentY + 7);
      currentX += colWidths[index];
    });
    
    this.currentY += 12;
    
    // Table rows
    data.forEach((item, rowIndex) => {
      this.checkPageSpace(12);
      
      // Alternating row background
      if (rowIndex % 2 === 1) {
        this.doc.setFillColor(...this.hexToRgb(COLORS.alternateRow));
        this.doc.rect(LAYOUT.margins.left, this.currentY - 2, this.contentWidth, 10, 'F');
      }
      
      currentX = LAYOUT.margins.left;
      
      // Description column
      this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.normal);
      this.doc.setFontSize(TYPOGRAPHY.sizes.caption);
      this.doc.setTextColor(...this.hexToRgb(COLORS.textPrimary));
      const descLines = this.doc.splitTextToSize(item.description, colWidths[0] - 4);
      this.doc.text(descLines[0], currentX + 2, this.currentY + 5);
      currentX += colWidths[0];
      
      // Work Type column (colored)
      this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
      this.doc.setTextColor(...this.hexToRgb(item.workTypeColor));
      this.doc.text(item.workType, currentX + 2, this.currentY + 5);
      currentX += colWidths[1];
      
      // Original Amount column
      this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.normal);
      this.doc.setTextColor(...this.hexToRgb(COLORS.textPrimary));
      const formattedOriginal = item.originalAmount > 0 ? new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(item.originalAmount) : '-';
      this.doc.text(formattedOriginal, currentX + 2, this.currentY + 5);
      currentX += colWidths[2];
      
      // New Amount column
      const formattedNew = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(item.newAmount);
      this.doc.text(formattedNew, currentX + 2, this.currentY + 5);
      currentX += colWidths[3];
      
      // Price Change column (colored based on increase/decrease)
      if (item.priceChange !== 0) {
        if (item.priceChange > 0) {
          this.doc.setTextColor(255, 0, 0); // Red for increase
        } else {
          this.doc.setTextColor(0, 128, 0); // Green for decrease
        }
        this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
        const formattedChange = new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
        }).format(item.priceChange);
        this.doc.text(formattedChange, currentX + 2, this.currentY + 5);
      } else {
        this.doc.setTextColor(...this.hexToRgb(COLORS.textPrimary));
        this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.normal);
        this.doc.text('-', currentX + 2, this.currentY + 5);
      }
      currentX += colWidths[4];
      
      // Warranty Status column (RED)
      this.doc.setFont(TYPOGRAPHY.fonts.primary, TYPOGRAPHY.weights.bold);
      this.doc.setTextColor(255, 0, 0); // Bright red
      this.doc.text(item.warrantyStatus, currentX + 2, this.currentY + 5);
      
      this.currentY += 10;
    });
    
    // Add bottom border
    this.doc.setDrawColor(...this.hexToRgb(COLORS.textMuted));
    this.doc.setLineWidth(0.3);
    this.doc.line(LAYOUT.margins.left, this.currentY, LAYOUT.margins.left + this.contentWidth, this.currentY);
  }

  public save(filename: string): void {
    this.doc.save(filename);
  }

  public output(type: string = 'blob'): any {
    if (type === 'blob') {
      return new Blob([this.doc.output('arraybuffer')], { type: 'application/pdf' });
    }
    return this.doc.output(type as any);
  }
}

// Export function for easy use
export const generatePremiumClaimReport = (claimData: PremiumClaimData): Blob => {
  const generator = new PremiumPdfGenerator();
  generator.generateClaimReport(claimData);
  return generator.output('blob');
};